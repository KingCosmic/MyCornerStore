local world = require 'newiso.world'
local utils = require 'newiso.utils'
local b_utils = require 'bufferutils'

local f_url = '#factory'

-- what object should the chunks be centered around.
go.property('auto_center', true)
go.property('centered_go', msg.url())

go.property('tl_buffer', resource.buffer('/newiso/buffers/tl.buffer'))
go.property('tm_buffer', resource.buffer('/newiso/buffers/tm.buffer'))
go.property('tr_buffer', resource.buffer('/newiso/buffers/tr.buffer'))

go.property('ml_buffer', resource.buffer('/newiso/buffers/ml.buffer'))
go.property('mm_buffer', resource.buffer('/newiso/buffers/mm.buffer'))
go.property('mr_buffer', resource.buffer('/newiso/buffers/mr.buffer'))

go.property('bl_buffer', resource.buffer('/newiso/buffers/bl.buffer'))
go.property('bm_buffer', resource.buffer('/newiso/buffers/bm.buffer'))
go.property('br_buffer', resource.buffer('/newiso/buffers/br.buffer'))

-- id, x, z
local meshes = {}

local function calculate_normals(vertices)
	local normals = {}

	-- Process every 9 values as a triangle (3 vertices Ã— 3 components each)
	for i = 1, #vertices, 9 do
		-- Extract the 3 vertices of this triangle
		local v1 = vmath.vector3(vertices[i], vertices[i+1], vertices[i+2])
		local v2 = vmath.vector3(vertices[i+3], vertices[i+4], vertices[i+5])
		local v3 = vmath.vector3(vertices[i+6], vertices[i+7], vertices[i+8])

		-- Calculate face normal
		local edge1 = v2 - v1
		local edge2 = v3 - v1
		local normal = vmath.normalize(vmath.cross(edge1, edge2))

		-- Add the same normal for all 3 vertices of this triangle (9 components)
		normals[i] = normal.x     -- v1.x normal
		normals[i+1] = normal.y   -- v1.y normal
		normals[i+2] = normal.z   -- v1.z normal
		normals[i+3] = normal.x   -- v2.x normal
		normals[i+4] = normal.y   -- v2.y normal
		normals[i+5] = normal.z   -- v2.z normal
		normals[i+6] = normal.x   -- v3.x normal
		normals[i+7] = normal.y   -- v3.y normal
		normals[i+8] = normal.z   -- v3.z normal
	end

	return normals
end

local function update_mesh(chunk)
	-- Clear existing data
	chunk.vertices = {}
	chunk.uvs = {}
	chunk.normals = {}
	chunk.colors = {}

	-- start at the top of our chunk and move down
	for y = #chunk.layers, 1, -1 do
		for z = 1, world.chunk_height do
			for x = 1, world.chunk_width do
				utils.add_terrain_quad(chunk, x, y, z)
			end
		end
	end

	-- chunk.normals = calculate_normals(chunk.vertices)
end

local function render_chunk(chunk, mesh)
	mesh.x = chunk.x
	mesh.z = chunk.z
	mesh.active = true

	go.set_position(vmath.vector3(mesh.x * utils.TILE_WIDTH * world.chunk_width, 0, mesh.z * utils.TILE_HEIGHT * world.chunk_height), mesh.id)

	update_mesh(chunk)

	b_utils.render_mesh(chunk, msg.url(nil, mesh.id, 'mesh'))
end

local function create_mesh(buffer, light)
	local id = factory.create(f_url, vmath.vector3(0, 0, 0))

	go.set(msg.url(nil, id, 'mesh'), 'vertices', buffer)
	go.set(msg.url(nil, id, 'mesh'), 'light', light)
	
	local mesh = {
		x = nil,
		z = nil,
		active = false,
		buffer,
		id = id
	}

	table.insert(meshes, mesh)
end

function init(self)
	-- Angled overhead light (down and slightly forward/to the side)
	self.light = vmath.vector4(1, 1, 2, 0)

	create_mesh(self.tl_buffer, self.light)
	create_mesh(self.tm_buffer, self.light)
	create_mesh(self.tr_buffer, self.light)

	create_mesh(self.ml_buffer, self.light)
	create_mesh(self.mm_buffer, self.light)
	create_mesh(self.mr_buffer, self.light)

	create_mesh(self.bl_buffer, self.light)
	create_mesh(self.bm_buffer, self.light)
	create_mesh(self.br_buffer, self.light)

	msg.post('.', 'acquire_input_focus')
end

local function get_free_mesh()
	for m = 1, #meshes do
		local mesh = meshes[m]

		if not mesh.active then
			return mesh, m
		end
	end

	return nil, -1
end

function update(self, dt)
	if not self.auto_center then
		return
	end

	local pos = go.get_position(self.centered_go)
	local current_chunks = utils.get_chunks_in_radius(pos.x, pos.z, 1)

	local active_mesh_keys = {}
	for m = 1, #meshes do
		local mesh = meshes[m]
		local key = utils.get_chunk_key(mesh.x, mesh.z)
		if not current_chunks[key] then
			mesh.active = false
		else
			active_mesh_keys[key] = true
		end
	end

	for chunk_key, c_pos in pairs(current_chunks) do
		if not active_mesh_keys[chunk_key] then
			local mesh = get_free_mesh()

			if mesh then
				local chunk = world.get_chunk(c_pos.x, c_pos.z)
				render_chunk(chunk, mesh)
			end
		end
	end
end

function on_message(self, message_id, message)
	if message_id == hash('update_mesh') then
		for m = 1, #meshes do
			local mesh = meshes[m]

			if mesh.x == message.x and mesh.z == message.z then
				local chunk = world.get_chunk(message.x, message.z)
				render_chunk(chunk, mesh)
			end
		end
	end
end