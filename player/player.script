local collision = require 'collision.tile_collision'
local b_utils = require 'bufferutils'
local world = require 'newiso.world'

go.property('idle', resource.tile_source('/assets/people/blank/blank_idle.tilesource'))
go.property('walk', resource.tile_source('/assets/people/blank/blank_walk.tilesource'))

go.property('camera', msg.url('/rendy'))

local DIRECTIONS = {
	UP = {
		anim = 'up',
		flipped = false,
	},
	UP_LEFT = {
		anim = 'up-left',
		flipped = false,
	},
	UP_RIGHT = {
		anim = 'up-left',
		flipped = true,
	},
	LEFT = {
		anim = 'left',
		flipped = false,
	},
	RIGHT = {
		anim = 'left',
		flipped = true,
	},
	DOWN = {
		anim = 'down',
		flipped = false,
	},
	DOWN_LEFT = {
		anim = 'down-left',
		flipped = false,
	},
	DOWN_RIGHT = {
		anim = 'down-left',
		flipped = true,
	},
}

local MAX_SPEED = 32

-- Movement vectors for different input combinations
local MOVEMENT_VECTORS = {
	-- Cardinal directions move straight on screen
	UP = vmath.vector3(-1, 1, 0),        -- Straight up
	DOWN = vmath.vector3(1, -1, 0),     -- Straight down
	LEFT = vmath.vector3(-1, -1, 0),     -- Straight left
	RIGHT = vmath.vector3(1, 1, 0),     -- Straight right
	UP_LEFT = vmath.vector3(-1, 0, 0),    -- Up Left
	UP_RIGHT = vmath.vector3(0, 1, 0),    -- Up Right
	DOWN_LEFT = vmath.vector3(0, -1, 0), -- Down Left
	DOWN_RIGHT = vmath.vector3(1, 0, 0)  -- Down right
}

-- tiles per row, tiles per column
local function get_frame_uv(frame, tpr, tpc)
	if frame == 0 then
		return { u1 = 0, v1 = 0, u2 = 1, v2 = 1 }
	end

	local tile_index = (frame - 1) % (tpr * tpc)
	local tile_x = tile_index % tpr
	local tile_y = math.floor(tile_index / tpr)

	local tile_size_u = 1.0 / tpr
	local tile_size_v = 1.0 / tpc

	local padding = 0.001
	local u1 = tile_x * tile_size_u + padding
	local u2 = (tile_x + 1) * tile_size_u - padding

	-- FLIP Y
	local v2 = 1.0 - (tile_y * tile_size_v + padding)
	local v1 = 1.0 - ((tile_y + 1) * tile_size_v - padding)

	return { u1 = u1, v1 = v1, u2 = u2, v2 = v2 }
end

-- Push vertices (x, y, z, u, v) in a flat array
local data = { vertices = {}, uvs = {}, normals = {}, colors = {} }
local function push_vertex(x, y, z, u, v)
	table.insert(data.vertices, x)
	table.insert(data.vertices, y)
	table.insert(data.vertices, z)
	table.insert(data.uvs, u)
	table.insert(data.uvs, v)
	table.insert(data.normals, -1)
	table.insert(data.normals, -1)
	table.insert(data.normals, -1)
	table.insert(data.colors, 1)
	table.insert(data.colors, 1)
	table.insert(data.colors, 1)
	table.insert(data.colors, 1)
end

local function create_quad(width, height, frame, tpr, tpc)
	local uv = get_frame_uv(frame, tpr, tpc)

	-- Define corners (clockwise)
	local bl_x, bl_y = 0, 0
	local br_x, br_y = width, 0
	local tl_x, tl_y = 0, 0
	local tr_x, tr_y = width, 0

	-- Triangle 1
	push_vertex(bl_x, bl_y, 0, uv.u1, uv.v1)
	push_vertex(br_x, br_y, 0, uv.u2, uv.v1)
	push_vertex(tl_x, tl_y, height, uv.u1, uv.v2)

	-- Triangle 2
	push_vertex(tl_x, tl_y, height, uv.u1, uv.v2)
	push_vertex(br_x, br_y, 0, uv.u2, uv.v1)
	push_vertex(tr_x, tr_y, height, uv.u2, uv.v2)
end

function init(self)
	msg.post('.', 'acquire_input_focus')

	self.input_x = 0
	self.input_y = 0
	self.direction = DIRECTIONS.DOWN
	self.last_direction = nil
	self.last_texture = 'idle'
	self.last_flipped = false

	local pos = go.get_position()
	pos.z = 16
	go.set_position(pos)
	create_quad(16, 32, 1, 8, 5)
	b_utils.render_mesh(data, '#mesh')

	-- get chunk we're standing on
	local chunk = world.get_chunk(0, 0)

	collision.set_layers(chunk.layers)
end

local function handle_animations(self)
	local texture = (self.input_x == 0 and self.input_y == 0) and 'idle' or 'walk'

	if self.last_texture ~= texture then
		go.set('#sprite', 'image', texture == 'idle' and self.idle or self.walk)
		self.last_texture = texture
	end

	if self.last_direction ~= self.direction then
		if self.last_direction == nil or self.last_direction.anim ~= self.direction.anim then
			sprite.play_flipbook('#sprite', self.direction.anim)
		end
		if self.last_direction == nil or self.last_direction.flipped ~= self.direction.flipped then
			sprite.set_hflip('#sprite', self.direction.flipped)
		end
		self.last_direction = self.direction
	end
end

function update(self, dt)
	if self.input_x ~= 0 or self.input_y ~= 0 then
		local pos = go.get_position()
		local movement_vector = vmath.vector3()

		-- Determine movement vector based on input combination
		if self.input_x > 0 and self.input_y > 0 then
			movement_vector = MOVEMENT_VECTORS.UP_RIGHT
		elseif self.input_x > 0 and self.input_y < 0 then
			movement_vector = MOVEMENT_VECTORS.DOWN_RIGHT
		elseif self.input_x < 0 and self.input_y > 0 then
			movement_vector = MOVEMENT_VECTORS.UP_LEFT
		elseif self.input_x < 0 and self.input_y < 0 then
			movement_vector = MOVEMENT_VECTORS.DOWN_LEFT
		elseif self.input_x > 0 then
			movement_vector = MOVEMENT_VECTORS.RIGHT
		elseif self.input_x < 0 then
			movement_vector = MOVEMENT_VECTORS.LEFT
		elseif self.input_y > 0 then
			movement_vector = MOVEMENT_VECTORS.UP
		elseif self.input_y < 0 then
			movement_vector = MOVEMENT_VECTORS.DOWN
		end

		-- Normalize movement to ensure consistent speed
		local target = vmath.vector3(0, 0, pos.z)
		local normalized_movement = vmath.normalize(movement_vector)
		target.x = pos.x + (normalized_movement.x * MAX_SPEED * dt)
		target.y = pos.y + (normalized_movement.y * MAX_SPEED * dt)

		local player = {
			x = pos.x,
			y = pos.y,
			z = pos.z,
			width = 1,
			height = 1,
			depth = 8
		}

		local move_result = collision.move_with_collision(
			player.x, player.y, player.z,
			target.x, target.y, target.z,
			player.width, player.height, player.depth
		)

		go.set_position(vmath.vector3(move_result.x, move_result.y, move_result.z))
	end

	-- handle_animations(self)
end

function on_input(self, action_id, action)
	-- Handle input - store raw input values
	if action_id == hash('move-up') then
		self.input_y = (action.released and 0) or 1
	elseif action_id == hash('move-down') then
		self.input_y = (action.released and 0) or -1
	elseif action_id == hash('move-left') then
		self.input_x = (action.released and 0) or -1
	elseif action_id == hash('move-right') then
		self.input_x = (action.released and 0) or 1
	end

	-- Determine animation direction based on input
	local direction = self.direction -- Default to current direction

	if self.input_x > 0 then
		direction = DIRECTIONS.RIGHT
	elseif self.input_x < 0 then
		direction = DIRECTIONS.LEFT
	end

	if self.input_y > 0 then
		if self.input_x > 0 then
			direction = DIRECTIONS.UP_RIGHT
		elseif self.input_x < 0 then
			direction = DIRECTIONS.UP_LEFT
		else
			direction = DIRECTIONS.UP
		end
	elseif self.input_y < 0 then
		if self.input_x > 0 then
			direction = DIRECTIONS.DOWN_RIGHT
		elseif self.input_x < 0 then
			direction = DIRECTIONS.DOWN_LEFT
		else
			direction = DIRECTIONS.DOWN
		end
	end

	self.direction = direction
end