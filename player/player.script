local collision = require 'collision.tile_collision'
local world = require 'newiso.world'

go.property('idle', resource.tile_source('/assets/people/blank/blank_idle.tilesource'))
go.property('walk', resource.tile_source('/assets/people/blank/blank_walk.tilesource'))

go.property('camera', msg.url('/rendy'))

local DIRECTIONS = {
	UP = {
		anim = 'up',
		flipped = false,
	},
	UP_LEFT = {
		anim = 'up-left',
		flipped = true,
	},
	UP_RIGHT = {
		anim = 'up-left',
		flipped = false,
	},
	LEFT = {
		anim = 'left',
		flipped = true,
	},
	RIGHT = {
		anim = 'left',
		flipped = false,
	},
	DOWN = {
		anim = 'down',
		flipped = false,
	},
	DOWN_LEFT = {
		anim = 'down-left',
		flipped = true,
	},
	DOWN_RIGHT = {
		anim = 'down-left',
		flipped = false,
	},
}

local MAX_SPEED = 32

-- Movement vectors for different input combinations
local MOVEMENT_VECTORS = {
	-- Cardinal directions move straight on screen
	UP = vmath.vector3(-1, 0, 1),        	-- Straight up
	DOWN = vmath.vector3(1, 0, -1),     	-- Straight down
	LEFT = vmath.vector3(1, 0, 1),     		-- Straight left
	RIGHT = vmath.vector3(-1, 0, -1),     	-- Straight right
	UP_LEFT = vmath.vector3(0, 0, 1),    	-- Up Left
	UP_RIGHT = vmath.vector3(-1, 0, 0),    	-- Up Right
	DOWN_LEFT = vmath.vector3(1, 0, 0), 	-- Down Left
	DOWN_RIGHT = vmath.vector3(0, 0, -1)  	-- Down right
}

function init(self)
	msg.post('.', 'acquire_input_focus')

	self.input_x = 0
	self.input_y = 0
	self.direction = DIRECTIONS.DOWN
	self.last_direction = nil
	self.last_texture = 'idle'
	self.last_flipped = false

	local pos = go.get_position()

	-- get chunk we're standing on
	local chunk = world.get_chunk(pos.x, pos.z)

	collision.set_layers(chunk.layers)
end

local function handle_animations(self)
	local texture = (self.input_x == 0 and self.input_y == 0) and 'idle' or 'walk'

	if self.last_texture ~= texture then
		go.set('#sprite', 'image', texture == 'idle' and self.idle or self.walk)
		self.last_texture = texture
	end

	if self.last_direction ~= self.direction then
		if self.last_direction == nil or self.last_direction.anim ~= self.direction.anim then
			sprite.play_flipbook('#sprite', self.direction.anim)
		end
		if self.last_direction == nil or self.last_direction.flipped ~= self.direction.flipped then
			sprite.set_hflip('#sprite', self.direction.flipped)
		end
		self.last_direction = self.direction
	end
end

local function face_camera_y(self)
	-- get camera forward
	local cam_rot = go.get_rotation(self.camera)
	local cam_forward = vmath.rotate(cam_rot, vmath.vector3(0, 0, -1))

	-- Flatten to XZ plane so it doesn't tilt
	cam_forward.y = 0
	cam_forward = vmath.normalize(cam_forward)

	-- Get angle around Y
	local angle = math.atan2(cam_forward.x, cam_forward.y)
	-- Defold's forward is -Z

	-- Build quaternion rotation around Y
	local rot = vmath.quat_rotation_y(angle)

	go.set_rotation(rot)
end

function update(self, dt)
	if self.input_x ~= 0 or self.input_y ~= 0 then
		local pos = go.get_position()
		local movement_vector = vmath.vector3()

		-- Determine movement vector based on input combination
		if self.input_x > 0 and self.input_y > 0 then
			movement_vector = MOVEMENT_VECTORS.UP_RIGHT
		elseif self.input_x > 0 and self.input_y < 0 then
			movement_vector = MOVEMENT_VECTORS.DOWN_RIGHT
		elseif self.input_x < 0 and self.input_y > 0 then
			movement_vector = MOVEMENT_VECTORS.UP_LEFT
		elseif self.input_x < 0 and self.input_y < 0 then
			movement_vector = MOVEMENT_VECTORS.DOWN_LEFT
		elseif self.input_x > 0 then
			movement_vector = MOVEMENT_VECTORS.RIGHT
		elseif self.input_x < 0 then
			movement_vector = MOVEMENT_VECTORS.LEFT
		elseif self.input_y > 0 then
			movement_vector = MOVEMENT_VECTORS.UP
		elseif self.input_y < 0 then
			movement_vector = MOVEMENT_VECTORS.DOWN
		end

		-- Normalize movement to ensure consistent speed
		local target = vmath.vector3(0, pos.y, 0)
		local normalized_movement = vmath.normalize(movement_vector)
		target.x = pos.x + (normalized_movement.x * MAX_SPEED * dt)
		target.z = pos.z + (normalized_movement.z * MAX_SPEED * dt)

		local player = {
			x = pos.x,
			y = pos.y,
			z = pos.z,
			width = 7,
			height = 7,
			depth = 8
		}

		-- get chunk we're standing on
		local chunk = world.get_chunk(pos.x, pos.z)
		collision.set_layers(chunk.layers)

		local move_result = collision.move_with_collision(
			player.x, player.y, player.z,
			target.x, target.y, target.z,
			player.width, player.height, player.depth
		)

		go.set_position(vmath.vector3(move_result.x, move_result.y, move_result.z))
	end

	handle_animations(self)
	-- handle_rotation(self)
end

function on_input(self, action_id, action)
	-- Handle input - store raw input values
	if action_id == hash('key_w') then
		self.input_y = (action.released and 0) or 1
	elseif action_id == hash('key_s') then
		self.input_y = (action.released and 0) or -1
	elseif action_id == hash('key_a') then
		self.input_x = (action.released and 0) or -1
	elseif action_id == hash('key_d') then
		self.input_x = (action.released and 0) or 1
	end

	if action_id == hash('key_q') then
		self.input_q = (action.released and 0) or 1
	elseif action_id == hash('key_e') then
		self.input_e = (action.released and 0) or 1
	end

	-- Determine animation direction based on input
	local direction = self.direction -- Default to current direction

	if self.input_x > 0 then
		direction = DIRECTIONS.RIGHT
	elseif self.input_x < 0 then
		direction = DIRECTIONS.LEFT
	end

	if self.input_y > 0 then
		if self.input_x > 0 then
			direction = DIRECTIONS.UP_RIGHT
		elseif self.input_x < 0 then
			direction = DIRECTIONS.UP_LEFT
		else
			direction = DIRECTIONS.UP
		end
	elseif self.input_y < 0 then
		if self.input_x > 0 then
			direction = DIRECTIONS.DOWN_RIGHT
		elseif self.input_x < 0 then
			direction = DIRECTIONS.DOWN_LEFT
		else
			direction = DIRECTIONS.DOWN
		end
	end

	self.direction = direction
end